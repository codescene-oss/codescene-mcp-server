import json
import os
import unittest
from unittest import mock

from fastmcp import FastMCP

from utils import post_refactor

from . import AutoRefactor

# Use mock data generated by running the CLI commands
MOCK_DATA_FILES = {
    "parse-fns": "src/code_health_auto_refactor/parse_fns.json",
    "review": "src/code_health_auto_refactor/review_data.json",
}


def mock_run_local_tool(command: list, cwd: str = None):
    cli_command = command[1]
    with open(MOCK_DATA_FILES[cli_command], encoding="utf-8") as file:
        return file.read()


class TestAutoRefactor(unittest.TestCase):
    @mock.patch(
        "code_health_auto_refactor.auto_refactor.find_git_root",
        return_value="/some-path",
    )
    @mock.patch.dict(os.environ, {"CS_ACE_ACCESS_TOKEN": "some-token", "CS_MOUNT_PATH": "/some-path"})
    def test_refactor(self, mock_find_git_root):
        def mock_post_refactor(payload: dict) -> dict:
            payload["source-snippet"].pop("body")

            # Check that the payload for ACE looks like it should...
            self.assertEqual(
                {
                    "api-version": "v2",
                    "source-snippet": {"file-type": "cpp", "function-type": "MemberFn"},
                    "review": [
                        {"category": "Complex Method", "start-line": 1},
                        {"category": "Complex Conditional", "start-line": 13},
                    ],
                },
                payload,
            )

            # ...and return a dummy response
            return {
                "code": "public void start() {}",
                "metadata": {},
                "confidence": {
                    "description": "high-confidence",
                },
                "reasons": [{"summary": "The Large Method code smell remains, but the overall code health improves."}],
                "refactoring-properties": {
                    "added-code-smells": [
                        "Large Method",
                        "Bumpy Road Ahead",
                        "Complex Method",
                    ],
                    "removed-code-smells": [],
                },
                "reasons-with-details": [{"summary": "The Large Method code smell remains, but the overall code health improves."}],
            }

        self.instance = AutoRefactor(
            FastMCP("Test"),
            {
                "post_refactor_fn": mock_post_refactor,
                "run_local_tool_fn": mock_run_local_tool,
            },
        )

        expected = {
            "code": "public void start() {}",
            "declarations": "",
            "confidence": "high-confidence",
            "reasons": ["The Large Method code smell remains, but the overall code health improves."],
        }

        result = self.instance.code_health_auto_refactor("/some-path/some-file.cpp", "Document::moveObject")

        self.assertEqual(expected, json.loads(result))

    @mock.patch(
        "code_health_auto_refactor.auto_refactor.find_git_root",
        return_value="/some-path",
    )
    @mock.patch.dict(os.environ, {"CS_ACE_ACCESS_TOKEN": "some-token", "CS_MOUNT_PATH": "/some-path"})
    def test_refactor_throws(self, mock_find_git_root):
        def raise_exception(*kwargs):
            raise Exception("Some error")

        self.instance = AutoRefactor(
            FastMCP("Test"),
            {
                "post_refactor_fn": None,
                "run_local_tool_fn": raise_exception,
            },
        )

        expected = "Error: Some error"
        result = self.instance.code_health_auto_refactor("/some-path/some-file.cpp", "Document::moveObject")

        self.assertEqual(expected, result)

    @mock.patch(
        "code_health_auto_refactor.auto_refactor.find_git_root",
        return_value="/some-path",
    )
    @mock.patch.dict(os.environ, {"CS_ACE_ACCESS_TOKEN": "some-token", "CS_MOUNT_PATH": "/some-path"})
    def test_refactor_missing_function(self, mock_find_git_root):
        self.instance = AutoRefactor(
            FastMCP("Test"),
            {
                "post_refactor_fn": None,
                "run_local_tool_fn": mock_run_local_tool,
            },
        )

        expected = "Error: Couldn't find function: missingFunction"
        result = self.instance.code_health_auto_refactor("/some-path/some-file.cpp", "missingFunction")

        self.assertEqual(expected, result)

    @mock.patch(
        "code_health_auto_refactor.auto_refactor.find_git_root",
        return_value="/some-path",
    )
    @mock.patch.dict(os.environ, {"CS_ACE_ACCESS_TOKEN": "some-token", "CS_MOUNT_PATH": "/some-path"})
    def test_refactor_no_code_smells(self, mock_find_git_root):
        self.instance = AutoRefactor(
            FastMCP("Test"),
            {
                "post_refactor_fn": None,
                "run_local_tool_fn": mock_run_local_tool,
            },
        )

        expected = "Error: No code smells were found in Document::isPerformingTransaction"
        result = self.instance.code_health_auto_refactor("/some-path/some-file.cpp", "Document::isPerformingTransaction")

        self.assertEqual(expected, result)

    @mock.patch.dict(os.environ, {"CS_MOUNT_PATH": "/some-path"})
    def test_refactor_no_token(self):
        self.instance = AutoRefactor(
            FastMCP("Test"),
            {
                "post_refactor_fn": None,
                "run_local_tool_fn": None,
            },
        )

        expected = "Error: This tool needs a token valid for CodeScene ACE in CS_ACE_ACCESS_TOKEN. See the ACE activation instructions in https://github.com/codescene-oss/codescene-mcp-server?tab=readme-ov-file#-activate-ace-in-codescene-mcp"
        result = self.instance.code_health_auto_refactor("/some-path/some-file.cpp", "Document::isPerformingTransaction")

        self.assertEqual(expected, result)

    @mock.patch(
        "code_health_auto_refactor.auto_refactor.find_git_root",
        return_value="/some-path",
    )
    @mock.patch.dict(
        os.environ,
        {"CS_ACE_ACCESS_TOKEN": "invalid-token", "CS_MOUNT_PATH": "/some-path"},
    )
    def test_refactor_invalid_token(self, mock_find_git_root):
        self.instance = AutoRefactor(
            FastMCP("Test"),
            {
                "post_refactor_fn": post_refactor,
                "run_local_tool_fn": mock_run_local_tool,
            },
        )

        expected = "Error: HttpClientError 401: The token is not valid."
        result = self.instance.code_health_auto_refactor("/some-path/some-file.cpp", "Document::moveObject")

        self.assertEqual(expected, result)

    @mock.patch(
        "code_health_auto_refactor.auto_refactor.find_git_root",
        return_value="/some-path",
    )
    @mock.patch.dict(os.environ, {"CS_ACE_ACCESS_TOKEN": "some-token"}, clear=False)
    def test_get_cli_file_path_without_mount_path(self, mock_find_git_root):
        """Test that _get_cli_file_path returns relative path when CS_MOUNT_PATH is not set."""
        # Remove CS_MOUNT_PATH if it exists
        os.environ.pop("CS_MOUNT_PATH", None)

        self.instance = AutoRefactor(
            FastMCP("Test"),
            {
                "post_refactor_fn": None,
                "run_local_tool_fn": mock_run_local_tool,
            },
        )

        result = self.instance._get_cli_file_path("/some-path/src/file.cpp", "/some-path")

        # Should return relative path
        self.assertEqual("src/file.cpp", result)
